#!/usr/bin/python# Script:  mkinput_ghost_all.py# Purpose: Make input file with ghost particles in the lamellae position# Syntax:  mkinput_ghost_all.py# Example: mkinput_ghost_all.py# Author:  Mark Stevens# Modified: Lisa Hall 1/10, Kevin Shen 1/2016, Mitchell Wendt 7/2016# Change to box center of 0 (-L/2 to L/2)# Chains are random walk.import sys, string, mathfrom numpy import *from random import *# INPUT PARAMETERsnbeads = 40                # number of beads in monomer (3, 5, 7, or 9 for ionomer project)fA = 0.5nmonomersperpoly = 1      # total (including x) number of monomers in polymernpoly =  480                # number of polymersminsep = 1.0                # allowed separation in overlap check       dens = 0.85               # bead densitybond = 0.97  # bond length. depends on bond potential, but close to 1 is good enoughminsep2 = minsep*minsepneutralizedfraction = 1chargeonunneutralized = 0# Label schemes# type names: conducting block(PEO), nonconducting block(PS)#           0     1     2     atype = ( '00', 'CB', 'NB' )# define monomerif (nbeads == 40):    sequence = [1]*int(fA*nbeads) + [2]*int((1-fA)*nbeads)else:    sys.exit ("define sequence of monomers.")# filesINPUT_LAMMPS = open('input_ghostall.lammps', 'w')print sequencenmonomers=nmonomersperpoly*npolyprint nmonomers# constantsntypes = 4 ntot = nmonomers*nbeadsvol = (ntot)/densdim = ntot+1#Ghost Particle Constantsnlayers = 2                                      #number of lamellar layers#xd, yd, and zd are the box dimensions generated from running npt without ghosts for 10mil timestepsxd = 26.480464633825079yd = 26.480464633825079zd = 34.819861778846153layersize = zd / (nlayers * 2.)                   #z dimension of one layerghostzlayers = 6                                 #ghost particles in the z direction in a layerghostxlayers = int(ghostzlayers*(xd/layersize))  #ghost particles in the x direction in a layerghostylayers = int(ghostzlayers*(xd/layersize))  #ghost particles in the z direction in a layerspacing = zd / (2. * nlayers) / ghostzlayers                  #amount of space between each ghost particle#Determine Box Size, Redefine Constantsxd = spacing * ghostxlayersyd = spacing * ghostylayerszd = spacing * ghostzlayers * 2. * nlayers#x, y, and z are half of the box dimensions (used as each dimension is centered at the origin)x = xd/2.y = yd/2.z = zd/2.layersize = zd / (nlayers * 2.)                   #z dimension of one layerspacing = zd / (2. * nlayers) / ghostzlayers                  #amount of space between each ghost particle#Determine nghostnghost = 0                   #number of ghost particles (determined as they are generated)for l in xrange(0, nlayers):    for _x in xrange(0, ghostxlayers):        for _y in xrange(0, ghostylayers):            for _z in xrange(0, ghostzlayers):                nghost += 1nghost2 = nghost# simulation cell parametershx = xdhy = ydhz = zdhx2 = xhy2 = yhz2 = zvol = hx*hy*hznbonds = ntot-npolyprint print "Total number of beads:",ntotprint "Number of chains =", npolyprint "beads in monomer =", nbeadsprint "monomers total =", nmonomersprint "Number of atoms types = ",ntypesprint " "print "Geometry:"print "dens = ", densprint "vol = ", volprint " "print "metric: %10.4f %10.4f %10.4f\n\n" % (hx, hy, hz)# init position variablesxc=zeros(dim + nghost + nghost2,float32)yc=zeros(dim + nghost + nghost2,float32)zc=zeros(dim + nghost + nghost2,float32)cx=zeros(dim)cy=zeros(dim)cz=zeros(dim)# Build polymerstypeb=[0]*dimmolnum=[0]*dimk=0for ix in xrange(npoly):    lengthcurrentpoly = 0    for iy in range(nmonomersperpoly):        currentmonomer = ix*nmonomersperpoly + iy        seqnum = 0        seq = sequence        for iz in seq:                seqnum = seqnum + 1                k = k + 1                lengthcurrentpoly = lengthcurrentpoly + 1                typeb[k] = iz                molnum[k] = ix + 1                if iy == 0 and seqnum == 1:                    xc[k] = random()*xd                    yc[k] = random()*yd                    zc[k] = random()*zd                else:                # pick random direction; scale to be bond length                     theta = random()*2*pi                    dz = random()*2 - 1                    dx = sqrt(1-dz**2)*cos(theta)                    dy = sqrt(1-dz**2)*sin(theta)                    r = sqrt(dx*dx+dy*dy+dz*dz)                    scale = bond/r                    dx = scale*dx                    dy = scale*dy                    dz = scale*dz                    xc[k] = xc[k-1] + dx                    yc[k] = yc[k-1] + dy                    zc[k] = zc[k-1] + dz#PLACE GHOST PARTICLESfor l in xrange(0, nlayers):    for _x in xrange(0, ghostxlayers):        for _y in xrange(0, ghostylayers):            for _z in xrange(0, ghostzlayers):                k += 1                xc[k] = (0.5 * spacing) - x + (_x * spacing)                yc[k] = (0.5 * spacing) - y + (_y * spacing)                zc[k] = (0.5 * spacing) - z + (_z * spacing) + (zd * (l * 1.0/ nlayers))for m in xrange(0, nlayers):    for _x in xrange(0, ghostxlayers):        for _y in xrange(0, ghostylayers):            for _z in xrange(0, ghostzlayers):                k += 1                xc[k] = (0.5 * spacing) - x + (_x * spacing)                yc[k] = (0.5 * spacing) - y + (_y * spacing)                zc[k] = (0.5 * spacing) - z + layersize + (_z * spacing) + (zd * (m * 1.0/ nlayers))for k in xrange(1,ntot+1):    if (xc[k] > hx):        cx[k] = int(xc[k]/hx)        xc[k] = xc[k] - cx[k]*hx - hx2    elif (xc[k] < 0.0):        cx[k] = -int((-xc[k]+hx)/hx)        xc[k] = xc[k] - cx[k]*hx - hx2    else:        cx[k] = 0        xc[k] = xc[k] - hx2    if (yc[k] > hy):        cy[k] = int(yc[k]/hy)        yc[k] = yc[k] - cy[k]*hy - hy2    elif (yc[k] < 0.0):        cy[k] = -int((-yc[k]+hy)/hy)        yc[k] = yc[k] - cy[k]*hy - hy2    else:        cy[k] = 0        yc[k] = yc[k] - hy2    if (zc[k] > hz):        cz[k] = int(zc[k]/hz)        zc[k] = zc[k] - cz[k]*hz - hz2    elif (zc[k] < 0.0):        cz[k] = -int((-zc[k]+hz)/hz)        zc[k] = zc[k] - cz[k]*hz - hz2    else:        cz[k] = 0        zc[k] = zc[k] - hz2# OUTPUT headers ---------------------------------------------------------------# input.lammps header INPUT_LAMMPS.write("#Diblock Copolymer KS 1/2016\n")INPUT_LAMMPS.write("#Number of lamellar layers: %1.0f\n" % nlayers)INPUT_LAMMPS.write("#Number of ghost particles: %7.0f\n" % nghost)INPUT_LAMMPS.write("#Number of ghost 2 particles: %7.0f\n" % nghost2)INPUT_LAMMPS.write("#Number of total ghost particles: %7.0f\n" % (nghost + nghost2))INPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("%10i    atoms\n" %     (ntot + nghost + nghost2))INPUT_LAMMPS.write("%10i    bonds\n" %     nbonds)INPUT_LAMMPS.write("%10i    angles\n" %     0)INPUT_LAMMPS.write("%10i    dihedrals\n" % 0)INPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("%10i    atom types\n" % ntypes)INPUT_LAMMPS.write("%10i    bond types\n" % 2)INPUT_LAMMPS.write("%10i    angle types\n" % 0)INPUT_LAMMPS.write("%10i    dihedral types\n" % 0)INPUT_LAMMPS.write("\n")INPUT_LAMMPS.write(" %16.8f %16.8f   xlo xhi\n" % (-x,x))INPUT_LAMMPS.write(" %16.8f %16.8f   ylo yhi\n" % (-y,y))INPUT_LAMMPS.write(" %16.8f %16.8f   zlo zhi\n" % (-z,z))INPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("Atoms\n")INPUT_LAMMPS.write("\n")# END OUTPUT headers -----------------------------------------------------------# Atoms outputmass = 1.0# Polymersi = 0imol = 0# positions for i in xrange(1,dim):    itype = typeb[i]    aname = atype[itype]    # could use a dictionary here between type and segname    if itype != 3:        imol = molnum[i]        segname = "POLY"    elif itype == 3:        #imol = npoly+1 #the molecule number for all counterions is the same; it's more like a group number        imol = i-ntot+npoly #LMH now each ion has its own molecule number        segname = "CION"    INPUT_LAMMPS.write("%6i %6i %2i %9.4f %9.4f %9.4f %6i %6i %6i\n" % (i, imol, typeb[i], xc[i], yc[i], zc[i], cx[i], cy[i], cz[i]))for j in xrange(dim,dim+nghost):    type3 = 3    imol = npoly + j - ntot    image_flag = 0    INPUT_LAMMPS.write("%6i %6i %2i %9.4f %9.4f %9.4f %6i %6i %6i\n" % (j, imol, type3, xc[j], yc[j], zc[j], image_flag, image_flag, image_flag))for n in xrange(dim+nghost,dim+nghost+nghost2):    type4 = 4    imol = npoly + j - ntot + nghost    image_flag = 0    INPUT_LAMMPS.write("%6i %6i %2i %9.4f %9.4f %9.4f %6i %6i %6i\n" % (n, imol, type4, xc[n], yc[n], zc[n], image_flag, image_flag, image_flag))# BondsINPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("Bonds\n")INPUT_LAMMPS.write("\n")ibond=0for i in xrange(1,ntot):        #if not at the end of the polymer        if molnum[i+1] == molnum[i]:            ibond = ibond+1 #the bond number            j=i+1            if i % 20 == 0:                INPUT_LAMMPS.write("%8i  2 %8i %8i\n" % (ibond,i,j))            else:                 INPUT_LAMMPS.write("%8i  1 %8i %8i\n" % (ibond,i,j))# MassesINPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("Masses\n")INPUT_LAMMPS.write("\n")for ii in xrange(1,ntypes+1):    INPUT_LAMMPS.write("%3i  1.0\n" % ii)#Close filesINPUT_LAMMPS.close()print "LAMMPS output complete."