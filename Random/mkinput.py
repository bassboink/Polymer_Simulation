#!/usr/bin/python# Script:  mkinput.py# Purpose: Make input file# Syntax:  mkinput.py# Example: mkinput.py# Author:  Mark Stevens# Modified: Lisa Hall 1/10, Kevin Shen 1/2016# Change to box center of 0 (-L/2 to L/2)# Chains are random walk.import sys, string, mathfrom numpy import *from random import *#-------------------------------------------------------------------------##  40 beads, 1 monomers, 800 poly = 32000 beads, 40 bead/monomer# INPUT PARAMETERsnbeads = 40                # number of beads in monomer (3, 5, 7, or 9 for ionomer project)fA = 0.5nmonomersperpoly = 1      # total (including x) number of monomers in polymernpoly =  250                # number of polymersminsep = 1.0                # allowed separation in overlap check       dens = 0.85               # bead densitybond = 0.97  # bond length. depends on bond potential, but close to 1 is good enoughminsep2 = minsep*minsepneutralizedfraction = 1chargeonunneutralized = 0# Label schemes# type names: conducting block(PEO), nonconducting block(PS)#           0     1     2     atype = ( '00', 'CB', 'NB' )# define monomerif (nbeads == 40):    sequence = [1]*int(fA*nbeads) + [2]*int((1-fA)*nbeads)else:    sys.exit ("define sequence of monomers.")# filesINPUT_LAMMPS = open('input_diblock.lammps', 'w')print sequencenmonomers=nmonomersperpoly*npolyprint nmonomers# constantsntypes = 2 # PS + PEO # neutral site + alpha site + pendant + counterion + unneutralized alpha+ unneutralized pendant/cb + extra uncharged beadntot = nmonomers*nbeadsvol = (ntot)/densside = vol**(1./3.)dim = ntot+1# simulation cell parametershx = sidehy = sidehz = sidehx2 = hx/2.hy2 = hy/2.hz2 = hz/2.vol = hx*hy*hznbonds = ntot-npolyprint print "Total number of beads:",ntotprint "Number of chains =", npolyprint "beads in monomer =", nbeadsprint "monomers total =", nmonomersprint "Number of atoms types = ",ntypesprint " "print "Geometry:"print "dens = ", densprint "vol = ", volprint " "print "metric: %10.4f %10.4f %10.4f\n\n" % (hx, hy, hz)# init position variablesxc=zeros(dim,float32)yc=zeros(dim,float32)zc=zeros(dim,float32)cx=zeros(dim)cy=zeros(dim)cz=zeros(dim)# Build polymerstypeb=[0]*dimmolnum=[0]*dimk=0for ix in xrange(npoly):    lengthcurrentpoly = 0    for iy in range(nmonomersperpoly):        currentmonomer = ix*nmonomersperpoly + iy        seqnum = 0        seq = sequence        for iz in seq:                seqnum = seqnum + 1                k = k + 1                lengthcurrentpoly = lengthcurrentpoly + 1                typeb[k] = iz                molnum[k] = ix + 1                if iy == 0 and seqnum == 1:                    xc[k] = random()*hx                    yc[k] = random()*hy                    zc[k] = random()*hz                else:                # pick random direction; scale to be bond length                     theta = random()*2*pi                    dz = random()*2 - 1                    dx = sqrt(1-dz**2)*cos(theta)                    dy = sqrt(1-dz**2)*sin(theta)                    r = sqrt(dx*dx+dy*dy+dz*dz)                    scale = bond/r                    dx = scale*dx                    dy = scale*dy                    dz = scale*dz                    xc[k] = xc[k-1] + dx                    yc[k] = yc[k-1] + dy                    zc[k] = zc[k-1] + dz# PBC #added -hx2 to everything to center box LMH; correct previous version error where it's different (not just the negative) depending on if/elif loop below for y and zfor k in xrange(1,ntot+1):    if (xc[k] > hx):        cx[k] = int(xc[k]/hx)        xc[k] = xc[k] - cx[k]*hx - hx2    elif (xc[k] < 0.0):        cx[k] = -int((-xc[k]+hx)/hx)        xc[k] = xc[k] - cx[k]*hx - hx2    else:        cx[k] = 0        xc[k] = xc[k] - hx2    if (yc[k] > hy):        cy[k] = int(yc[k]/hy)        yc[k] = yc[k] - cy[k]*hy - hy2    elif (yc[k] < 0.0):        cy[k] = -int((-yc[k]+hy)/hy)        yc[k] = yc[k] - cy[k]*hy - hy2    else:        cy[k] = 0        yc[k] = yc[k] - hy2    if (zc[k] > hz):        cz[k] = int(zc[k]/hz)        zc[k] = zc[k] - cz[k]*hz - hz2    elif (zc[k] < 0.0):        cz[k] = -int((-zc[k]+hz)/hz)        zc[k] = zc[k] - cz[k]*hz - hz2    else:        cz[k] = 0        zc[k] = zc[k] - hz2# OUTPUT headers ---------------------------------------------------------------# input.lammps header INPUT_LAMMPS.write("#Diblock Copolymer KS 1/2016\n")INPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("%10i    atoms\n" %     ntot)INPUT_LAMMPS.write("%10i    bonds\n" %     nbonds)INPUT_LAMMPS.write("%10i    angles\n" %     0)INPUT_LAMMPS.write("%10i    dihedrals\n" % 0)INPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("%10i    atom types\n" % ntypes)INPUT_LAMMPS.write("%10i    bond types\n" % 2)INPUT_LAMMPS.write("%10i    angle types\n" % 0)INPUT_LAMMPS.write("%10i    dihedral types\n" % 0)INPUT_LAMMPS.write("\n")INPUT_LAMMPS.write(" %16.8f %16.8f   xlo xhi\n" % (-hx2,hx2))INPUT_LAMMPS.write(" %16.8f %16.8f   ylo yhi\n" % (-hy2,hy2))INPUT_LAMMPS.write(" %16.8f %16.8f   zlo zhi\n" % (-hz2,hz2))INPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("Atoms\n")INPUT_LAMMPS.write("\n")# END OUTPUT headers -----------------------------------------------------------# Atoms outputmass = 1.0# Polymersi = 0imol = 0# positions for i in xrange(1,dim):    itype = typeb[i]    aname = atype[itype]    # could use a dictionary here between type and segname    if itype != 3:        imol = molnum[i]        segname = "POLY"    elif itype == 3:        #imol = npoly+1 #the molecule number for all counterions is the same; it's more like a group number        imol = i-ntot+npoly #LMH now each ion has its own molecule number        segname = "CION"    INPUT_LAMMPS.write("%6i %6i %2i %9.4f %9.4f %9.4f %6i %6i %6i\n" % (i, imol, typeb[i], xc[i], yc[i], zc[i], cx[i], cy[i], cz[i]))# BondsINPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("Bonds\n")INPUT_LAMMPS.write("\n")ibond=0for i in xrange(1,ntot):        #if not at the end of the polymer        if molnum[i+1] == molnum[i]:            ibond = ibond+1 #the bond number            j=i+1            if i % 20 == 0:                INPUT_LAMMPS.write("%8i  2 %8i %8i\n" % (ibond,i,j))            else:                 INPUT_LAMMPS.write("%8i  1 %8i %8i\n" % (ibond,i,j))# MassesINPUT_LAMMPS.write("\n")INPUT_LAMMPS.write("Masses\n")INPUT_LAMMPS.write("\n")for ii in xrange(1,ntypes+1):    INPUT_LAMMPS.write("%3i  1.0\n" % ii)#Close filesINPUT_LAMMPS.close()print "LAMMPS output complete."